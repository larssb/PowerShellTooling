#Requires -Module PSGraph
function Out-PSModuleCallGraph() {
<#
.DESCRIPTION
    Out-PSModuleCallGraph generates a call graph on a PowerShell module. The call graph is generated by parsing the public commands/functions of the module being analyzed. Identifying
    the commands/functions each one utilizes. Noting their scope and the chronological order by which they where called. Finally the graph is generated with the PSGraph module and
    saved in the format and on the media specified.
.INPUTS
    [String]ModuleName
    [String]ModuleRoot
.OUTPUTS
    A graphviz graph via the PSGraph module.
.NOTES
    On the analysis:
        - The analysis is based on parsing the AST of each command/public function in the analyzed module. You therefore do not get a sequence like graph over certain calls made
        if 'x' path in the program was followed. Rather the generated call graph represents the code written, static as it is, when parsed line by line, as it is read-in from files
        on disk, to identify the sub-routines called and to be able to present an overview of how parts of the program is thought to interact/can interact with eachother.
    Other:
        - Call graphs can be very useful when working with your own PowerShell module or a PS module developed by external parties. A call graph gives you an overview over the calling
        relationships of commands/functions in a program. Thereby making it possible to get a good overview of a PowerShell module and they its sub-routines interact with eachother.
    Pre-requisites:
        - The PSGraph module should already be installed.
.EXAMPLE
    Out-PSModuleCallGraph -ModuleName Pester
    This will generate a call graph on the Pester module.
.EXAMPLE
    Out-PSModuleCallGraph -ModuleRoot ./PowerShellTooling/
    This will generate a call graph on a properly defined PowerShell module in the folder 'PowerShellTooling'. A sub-folder to current folder. Useful if the module is not installed
    in one of the default PowerShell module installation locations.
.PARAMETER ExcludeDebugCommands
    Used to specify that you wish to exclude common debug commands such as > Write-Verbose & Write-Error.
.PARAMETER ModuleName
    The name of the module to analyze. Assumes that the module is installed in one of the default PowerShell module installation locations.
.PARAMETER ModuleRoot
    Full path to the root folder of the PowerShell module.
.PARAMETER OutputPath
    The path on which to store the generated call graph.
#>

    # Define parameters
    [CmdletBinding(DefaultParameterSetName = "Default")]
    [OutputType([Void])]
    param(
        [Parameter()]
        [Parameter(ParameterSetName="ByModuleName")]
        [Parameter(ParameterSetName="ByModuleRoot")]
        [Switch]$ExcludeDebugCommands,
        [Parameter(Mandatory, ParameterSetName="ByModuleName")]
        [ValidateNotNullOrEmpty()]
        [String]$ModuleName,
        [Parameter(Mandatory, ParameterSetName="ByModuleRoot")]
        [ValidateNotNullOrEmpty()]
        [String]$ModuleRoot,
        [Parameter()]
        [Parameter(ParameterSetName="ByModuleName")]
        [Parameter(ParameterSetName="ByModuleRoot")]
        [ValidateNotNullOrEmpty()]
        [String]$OutputPath
    )

    #############
    # Execution #
    #############
    Begin {
        if ($PSBoundParameters.ContainsKey('ModuleName')) {
            # Import the specified module by name. Therefore, loaded from one of the default PowerShell module path locations.
            $Module = Import-Module -DisableNameChecking -Name $ModuleName -PassThru
        } else {
            # Import the specified module by its fullname/path.
            $Module = Import-Module -DisableNameChecking -Name $ModuleRoot -PassThru
        }

        # Get the public commands/functions loaded by the module. Need them in order to control the scope and type of 'x' command/function being analyzed later on.
        $PublicFunctions = Get-Command -Module $Module.Name
        Write-Verbose -Message "The public functions retrieved > $($PublicFunctions.Name | Out-String)"

        # Collection to hold private functions
        [System.Collections.ArrayList]$PrivateFunctions = New-Object System.Collections.ArrayList

        # Collection to hold the call hierarchy of the analyzed module
        [System.Collections.ArrayList]$CallGraphObjects = New-Object System.Collections.ArrayList

        # Prepare to exclude common debug commands
        if ($ExcludeDebugCommands) {
            $DebugCommandsToExclude = @('Write-Debug','Write-Error','Write-Verbose')
        } else {
            $DebugCommandsToExclude = @()
        }

        # Short-hand values for commands to be translated to their fullname counterpart
        $FullNameCommands = @{
            "%" = "ForEach-Object"
            "?" = "Where-Object"
            "And" = "GherkinStep"
            "But" = "GherkinStep"
            "cd" = "Set-Location"
            "chdir" = "Set-Location"
            "clc" = "Clear-Content"
            "clear" = "Clear-Host"
            "clhy" = "Clear-History"
            "cli" = "Clear-Item"
            "clp" = "Clear-ItemProperty"
            "cls" = "Clear-Host"
            "clv" = "Clear-Variable"
            "copy" = "Copy-Item"
            "cpi" = "Copy-Item"
            "cvpa" = "Convert-Path"
            "dbp" = "Disable-PSBreakpoint"
            "del" = "Remove-Item"
            "DiGraph" = "Graph"
            "dir" = "Get-ChildItem"
            "ebp" = "Enable-PSBreakpoint"
            "echo" = "Write-Output"
            "epal" = "Export-Alias"
            "epcsv" = "Export-Csv"
            "erase" = "Remove-Item"
            "etsn" = "Enter-PSSession"
            "exsn" = "Exit-PSSession"
            "fc" = "Format-Custom"
            "fhx" = "Format-Hex"
            "fl" = "Format-List"
            "foreach" = "ForEach-Object"
            "ft" = "Format-Table"
            "fw" = "Format-Wide"
            "gal" = "Get-Alias"
            "gbp" = "Get-PSBreakpoint"
            "gc" = "Get-Content"
            "gci" = "Get-ChildItem"
            "gcm" = "Get-Command"
            "gcs" = "Get-PSCallStack"
            "gdr" = "Get-PSDrive"
            "ghy" = "Get-History"
            "gi" = "Get-Item"
            "Given" = "GherkinStep"
            "gjb" = "Get-Job"
            "gl" = "Get-Location"
            "gm" = "Get-Member"
            "gmo" = "Get-Module"
            "gp" = "Get-ItemProperty"
            "gps" = "Get-Process"
            "gpv" = "Get-ItemPropertyValue"
            "group" = "Group-Object"
            "gsn" = "Get-PSSession"
            "gtz" = "Get-TimeZone"
            "gu" = "Get-Unique"
            "gv" = "Get-Variable"
            "h" = "Get-History"
            "history" = "Get-History"
            "icm" = "Invoke-Command"
            "iex" = "Invoke-Expression"
            "ihy" = "Invoke-History"
            "ii" = "Invoke-Item"
            "ipal" = "Import-Alias"
            "ipcsv" = "Import-Csv"
            "ipmo" = "Import-Module"
            "irm" = "Invoke-RestMethod"
            "iwr" = "Invoke-WebRequest"
            "kill" = "Stop-Process"
            "md" = "mkdir"
            "measure" = "Measure-Object"
            "mi" = "Move-Item"
            "move" = "Move-Item"
            "mp" = "Move-ItemProperty"
            "nal" = "New-Alias"
            "ndr" = "New-PSDrive"
            "ni" = "New-Item"
            "nmo" = "New-Module"
            "nsn" = "New-PSSession"
            "nv" = "New-Variable"
            "oh" = "Out-Host"
            "popd" = "Pop-Location"
            "pushd" = "Push-Location"
            "pwd" = "Get-Location"
            "r" = "Invoke-History"
            "rbp" = "Remove-PSBreakpoint"
            "rcjb" = "Receive-Job"
            "rcsn" = "Receive-PSSession"
            "rd" = "Remove-Item"
            "rdr" = "Remove-PSDrive"
            "ren" = "Rename-Item"
            "ri" = "Remove-Item"
            "rjb" = "Remove-Job"
            "rmo" = "Remove-Module"
            "rni" = "Rename-Item"
            "rnp" = "Rename-ItemProperty"
            "rp" = "Remove-ItemProperty"
            "rsn" = "Remove-PSSession"
            "rv" = "Remove-Variable"
            "rvpa" = "Resolve-Path"
            "sajb" = "Start-Job"
            "sal" = "Set-Alias"
            "saps" = "Start-Process"
            "sbp" = "Set-PSBreakpoint"
            "select" = "Select-Object"
            "set" = "Set-Variable"
            "si" = "Set-Item"
            "sl" = "Set-Location"
            "sls" = "Select-String"
            "sp" = "Set-ItemProperty"
            "spjb" = "Stop-Job"
            "spps" = "Stop-Process"
            "sv" = "Set-Variable"
            "Then" = "GherkinStep"
            "type" = "Get-Content"
            "When" = "GherkinStep"
            "where" = "Where-Object"
            "wjb" = "Wait-Job"
        }
    }
    Process {
        <#
            - Analyze private functions in the module
        #>
        # Get all PS1 files
        $PS1Files = (Get-ChildItem -Path $Module.ModuleBase -Filter '*.ps1' -Recurse)
        Write-Verbose -Message "All *.ps1 files retrieved > $($PS1Files.Name | Out-String)"

        # Run through all the retrieved *.PS1 files >> to identify declared functions in them
        foreach ($PS1File in $PS1Files) {
            # Collection to hold the commands used by the function. Ordered to reflect the point-in-time of each commad invocation.
            [System.Collections.ArrayList]$FunctionCommandHierarchy = New-Object System.Collections.ArrayList

            $ast = [System.Management.Automation.PSParser]::Tokenize( (Get-Content -Path $PS1File.FullName), [ref]$null)

            # Identify the declared functions in the file
            $DeclaredFunctions = $ast.where( { $_.Type -eq "Keyword" -and $_.Content -eq "function" } )
            Write-Verbose -Message "There is $($DeclaredFunctions.Count) declared functions in the file named $($PS1File.Name)."

            foreach ($DeclaredFunction in $DeclaredFunctions) {
                # Derive the name of the declared function
                [String]$FunctionName = ($ast.where( { $_.Startline -eq $DeclaredFunction.StartLine -and $_.Type -eq "CommandArgument" } )).Content

                # Control if the function is a public function in the module being analyzed
                if (-not $PublicFunctions.Name.Contains($FunctionName)) {
                    $PrivateFunctions.Add($FunctionName) | Out-Null
                    Write-Verbose -Message "Found a private function named $FunctionName"

                    # Parse the AST of the private function to find the CommandArguments used
                    if ($DeclaredFunctions.Count -gt 1) {
                        <#
                            - There is more than 1 declared function in the file being parsed. Need to get the commands used by the current function in a controlled way.
                            If not, the risk is that CommandArguments used by other functions in the file will be incorrectly included.
                        #>
                        # Get the index of the current function.
                        $IdxOfThisDeclaredFunction = $DeclaredFunctions.IndexOf($DeclaredFunction)
                        Write-Verbose -Message "Idx of this functions is > $IdxOfThisDeclaredFunction"

                        # Ensure that we do not make out of bounds lookups
                        if (-not ($IdxOfThisDeclaredFunction+1 -gt $DeclaredFunctions.Count-1) ) {
                            [Bool]$ParseByEndline = $true

                            # Get the startline of the next function
                            $NextItemInDeclaredFunctions = $DeclaredFunctions.Item($IdxOfThisDeclaredFunction+1)
                            Write-Verbose -Message "Next item is > $($NextItemInDeclaredFunctions | Out-String)"
                            $ParseEndLine = $NextItemInDeclaredFunctions.StartLine-1
                        } else {
                            [Bool]$ParseByEndline = $false
                        }
                    } else {
                        [Bool]$ParseByEndline = $false
                    }

                    # Parse for commandarguments used by this function
                    if ($ParseByEndline) {
                        Write-Verbose -Message "Parsing by endline. Line to parse to is > $ParseEndLine"
                        $CommandsUsed = $ast.where( { $_.Type -eq "Command" -and $_.EndLine -le $ParseEndLine } )
                        Write-Verbose -Message "Found the following commands used in the private function $FunctionName > $($CommandsUsed | Out-String)"
                    } else {
                        Write-Verbose -Message "Not parsing by endline."
                        $CommandsUsed = $ast.where( { $_.Type -eq "Command" } )
                    }

                    if ($null -ne $CommandsUsed) {
                        # Ordered collection to hold the commands found in the command/function being analyzed
                        [System.Collections.ArrayList]$CommandsUsedInfo = New-Object System.Collections.Specialized.OrderedDictionary

                        foreach ($Command in $CommandsUsed) {
                            # "Translate" command short-hands to their full-length counterpart.
                            if ($FullNameCommands.Contains($Command.Content)) {
                                [String]$CommandName = $FullNameCommands."$($Command.Content)"
                            } else {
                                [String]$CommandName = $Command.Content
                            }

                            if ($DebugCommandsToExclude.Count -eq 0 -or $DebugCommandsToExclude -notcontains $CommandName) {
                                # Control the scope and type of the command. If it is an external, a public or a private command
                                $GetCommandData = Get-Command -Name $CommandName -ErrorAction SilentlyContinue # Okay to continue silently. If Get-Command fails to find an ast parsed Command it means that it is 'scope private'.
                                if ($null -ne $GetCommandData) {
                                    if ($GetCommandData.ModuleName -notmatch $Module.Name) {
                                        [String]$CommandScope = "External"
                                    } else {
                                        [String]$CommandScope = "Public"
                                    }
                                } else {
                                    [String]$CommandScope = "Private"
                                }
                                Write-Verbose -Message "The command $($CommandName) found in the private function $FunctionName has the following scope > $CommandScope"

                                # Create a custom object to hold the info on the command analyzed
                                $CommandInfo = @{
                                    "CommandName" = $CommandName
                                    "CommandScope" = $CommandScope
                                }
                                $CommandInfoCustomObject = New-Object -TypeName PSCustomObject -Property $CommandInfo

                                # Add the command info to the collection
                                $CommandsUsedInfo.Add($CommandInfoCustomObject) | Out-Null
                            }
                        } # End of foreach on $CommandsUsed in the ps1 file.

                        # Add the analyzed info to the collection that holds all the aggregated info, derived by analyzing the public function/command currently being iterated over
                        $FunctionCommandHierarchy.Add(@{
                            "Affiliation" = $FunctionName
                            "Commands" = $CommandsUsedInfo
                            "Type" = "PrivateCommands"
                        }) | Out-Null
                    } # End of conditional on "content" in $CommandsUsed
                } else {
                    Write-Verbose -Message "The function named $FunctionName is a public function"
                } # End of conditional on the function scope (private or public).
            } # End of foreach on each $DeclaredFunction in $DeclaredFunctions

            # Add the result of analyzing the PS1 file & its commands/functions to the CallGraphObjects collection
            $CallGraphObjects.Add($FunctionCommandHierarchy) | Out-Null
        }
        Write-Verbose -Message "$($PrivateFunctions.Count) private function found in the $($Module.Name)"

        <#
            - Analyze Public functions in the module.
        #>
        # Parse the AST of the public funtions to discover the CommandArguments used
        foreach ($PublicFunction in $PublicFunctions) {
            # Collection to hold the commands used by the function. Ordered to reflect the point-in-time of each commad invocation.
            [System.Collections.ArrayList]$PublicFunctionCommandHierarchy = New-Object System.Collections.ArrayList

            # Tokenize the AST
            $ast = [System.Management.Automation.PSParser]::Tokenize( $($PublicFunction.Definition), [ref]$null)

            # Get the commands used in the code (references to other functions/cmdlets in the code)
            $CommandsUsed = $ast.where( { $_.Type -eq "Command" } )

            if ($null -ne $CommandsUsed) {
                # Ordered collection to hold the commands found in the command/function being analyzed
                [System.Collections.ArrayList]$CommandsUsedInfo = New-Object System.Collections.Specialized.OrderedDictionary

                foreach ($Command in $CommandsUsed) {
                    # "Translate" command short-hands to their full-length counterpart.
                    if ($FullNameCommands.Contains($Command.Content)) {
                        [String]$CommandName = $FullNameCommands."$($Command.Content)"
                    } else {
                        [String]$CommandName = $Command.Content
                    }
                    Write-Verbose -Message "CommandName was derived to > $CommandName"

                    if ($DebugCommandsToExclude.Count -eq 0 -or $DebugCommandsToExclude -notcontains $CommandName) {
                        # Control if it is a private function in the module
                        if ($PrivateFunctions.Contains($CommandName)) {
                            [String]$CommandScope = "Private"
                        }

                        # Control if it is a public function in the module
                        if ($PublicFunctions.Name.Contains($CommandName)) {
                            [String]$CommandScope = "Public"
                        }

                        # Control if the command is defined in an external module
                        if (-not $PrivateFunctions.Contains($CommandName) -and -not $PublicFunctions.Name.Contains($CommandName)) {
                            [String]$CommandScope = "External"
                        }
                        Write-Verbose -Message "The command $($CommandName) found in the public function $PublicFunction has the following scope > $CommandScope"

                        # Create a custom object to hold the info on the command analyzed
                        $CommandInfo = @{
                            "CommandName" = $CommandName
                            "CommandScope" = $CommandScope
                        }
                        $CommandInfoCustomObject = New-Object -TypeName PSCustomObject -Property $CommandInfo

                        # Add the command info to the collection
                        $CommandsUsedInfo.Add($CommandInfoCustomObject) | Out-Null
                    } # End of conditional on Exclude
                } # End of foreach on $CommandsUsed

                # Add the analyzed info to the collection that holds all the aggregated info, derived by analyzing the public function/command currently being iterated over
                $PublicFunctionCommandHierarchy.Add(@{
                    "Affiliation" = $PublicFunction.Name
                    "Commands" = $CommandsUsedInfo
                    "Type" = "PublicCommands"
                }) | Out-Null
            }

            # Add the result of analyzing the Public function to the CallGraphObjects collection
            $CallGraphObjects.Add($PublicFunctionCommandHierarchy) | Out-Null
        }

        <#
            - Create the Graph
        #>
        $graphData = Graph ModuleCallGraph {
            # Graph root node. To which all other nodes will be rooted.
            Node ProjectRoot -Attribute @{label="$($Module.Name)";shape='invhouse'}

            # Create nodes on the graph on all the analyzed data
            foreach ($CallGraphObject in $CallGraphObjects) {
                if ($CallGraphObject.Type -eq "PublicCommands") {
                    # "Attach" the command/function to the root node
                    Edge ProjectRoot, $CallGraphObject.Affiliation
                }

                # Control that the command/function actually used any other commands/functions
                if ($CallGraphObject.Commands.CommandsUsedInfo.Count -gt 0) {
                    # Counter used to annotate the nodes with the chronological order by which the command was called
                    $CommandCounter = 1

                    # Create nodes for all the commands/functions the command/function uses
                    $CallGraphObject.Commands.GetEnumerator() | ForEach-Object {
                        Edge $CallGraphObject.Affiliation, $_.CommandName -Attributes @{label="$CommandCounter\n$($_.CommandScope)"}
                        $CommandCounter++
                    }
                }
            }
        }

        # Output the graph
        $graphData | Export-PSGraph -ShowGraph
    }
}